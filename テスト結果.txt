正常動作は【○】, エラーは【×】で表記

### A01.py
# 同じアドレスでの処理
01-01. 1つのアドレスからなるログから1つの故障期間の出力(最終応答結果が正常の場合)【○】
01-02. 1つのアドレスからなるログから複数の故障期間の出力(最終応答結果が正常の場合のみ)【○】
01-03. 1つのアドレスからなるログから1つの故障期間の出力(最終応答結果がタイムアウトの場合)【○】
01-04. 1つのアドレスからなるログから複数の故障期間の出力(最終応答結果が正常とタイムアウト両方の場合含む)【○】
01-05. 1つのアドレスからなるログから故障期間の出力(2回以上連続タイムアウトを含む場合)【×】
→【エラー原因】連続でタイムアウトが発生することを想定していない

# 複数アドレスでの処理
01-06. 複数アドレスからなるログから複数の故障期間の出力(最終応答結果が正常とタイムアウト両方の場合含む)【○】

### A02.py
一見正常動作しているようにみえるが以下の不備がある.
ソートしたあとのdfにおいてresultカラムがn行(inputで指定)以上連続しており,
さらに連続している行の中に異なるアドレスがある場合.
[具体例]
02_02.csvを読み込み、n=1としたとき, 

【ソートされたdf】
                 date         address result
0 2020-10-19 13:31:24   10.20.30.1/16      2
1 2020-10-19 13:32:24   10.20.30.1/16      -
2 2020-10-19 13:31:25   10.20.30.2/16      -
3 2020-10-19 13:32:25   10.20.30.2/16      1
4 2020-10-19 13:32:34  192.168.1.1/24      -

【最終的に出力されるdf】
          address       timeout_begin timeout_end consecutive duration
0   10.20.30.1/16 2020-10-19 13:32:24         NaN           2      NaN
1  192.168.1.1/24 2020-10-19 13:32:34         NaN           1      NaN

【エラー内容】
ソートされたdfの2, 3行目はそれぞれ別のアドレスであるが
出力されるdfでは連続してタイムアウトしたと判定される.

【原因】
連続タイムアウトの判定でアドレスの違いを考慮していないため.
タイムアウトしている行番号が連続した場合, 無条件で連続とみなしていた.
この判定をアドレスごとに行うべきであった.
groupbyを使いアドレスでdfを分割して修正しようとしたが上手くいかず.
