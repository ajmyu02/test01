# Profile
氏名: 吉田惇志
大学: 近畿大学

# ざっくり説明・感想
時間が足りず, 設問3の途中までの状態です.
pandasの扱いにあまり慣れていなかったので調べながら作ったためぐちゃぐちゃなコードです.
テスト結果の方も中途半端になっています.

# 開発環境など
言語: Python3
環境: AWS Cloud9
モジュール: numpy, pandas

# ログの読み込み
ディレクトリ内にlogフォルダを作り, その中にcsvファイルとして入れたものを読み込む

# 出力フォーマット
・pandasのdfで出力する
・日時はdatetime型に変換する

# 出力dfの各カラムの意味
address(str型): サーバアドレス
timeout_begin(datetime型): タイムアウトの開始日時
timeout_end(datetime型): 開始日時以降で応答があった日時(=復旧確定の日時)
consecutive(int型): タイムアウトの連続回数(1以上)
duration(int型) 故障期間の秒数, timeout_endとtimeout_beginの差をとる

# 想定していないこと
・読み込むcsvファイルが存在しない, または内容に不備がある
・inputで指定された型以外を入力する

# 指定されていないが考慮したこと
・同じアドレスで複数回の故障期間が存在するとき(例:故障→復旧→故障)
故障期間を一括せずにそれぞれの故障で算出
・該当アドレスの最終応答結果がタイムアウトのとき
故障のままと見なし, 故障期間は算出しない

### 以下, それぞれのプログラムの説明
# A01.py(設問1)
・タイムアウトが含まれるアドレスの抽出
タイムアウトが含まれていることを前提で作ったので, 含まれていないアドレスを除外す
るためにアドレスを抽出した(意味なかったかも)
重複を削除するために一度setにしたあと再びlistに戻す作業をしている.
・タイムアウトの後復旧しているかの判定
タイムアウトした行以降に同じアドレスで"-"以外が含まれている行があるかどうか
ない場合は復旧していないとみなす.
ある場合はその中から一番行番号が小さいものを復旧した日時とする.

# A02.py(設問2)
・連続でタイムアウトしているかの判定
連続を判定するために行番号(インデックス)を利用する.
タイムアウトしている行の行番号がn回以上連続している数字を二次元リストに入れていき管理する.
*例
n=2のとき
タイムアウトしている行番号が[1, 3, 4, 5, 7, 8, 10]の場合
リスト = [[3, 4, 5], [7, 8]]